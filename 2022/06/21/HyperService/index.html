

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shaoyu Li">
  <meta name="keywords" content="">
  
    <meta name="description" content="HyperService: Interoperability and Programmability Across Heterogeneous Blockchains 0. 摘要 区块链的互操作性，允许状态在不同的区块链之间传输，这对于促进主要的区块链发展很重要。存在的互操作性协议一般存在于区块链间原子代币的交换。然而，随着区块链由原来的分布式账本拓展为可编程状态机，区块链互操作性的范围也不再局限">
<meta property="og:type" content="article">
<meta property="og:title" content="HyperService">
<meta property="og:url" content="http://example.com/2022/06/21/HyperService/index.html">
<meta property="og:site_name" content="The refreshing spring breeze bath">
<meta property="og:description" content="HyperService: Interoperability and Programmability Across Heterogeneous Blockchains 0. 摘要 区块链的互操作性，允许状态在不同的区块链之间传输，这对于促进主要的区块链发展很重要。存在的互操作性协议一般存在于区块链间原子代币的交换。然而，随着区块链由原来的分布式账本拓展为可编程状态机，区块链互操作性的范围也不再局限">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-22T02:45:17.000Z">
<meta property="article:modified_time" content="2022-06-22T02:51:01.442Z">
<meta property="article:author" content="Shaoyu Li">
<meta property="article:tag" content="Blockchain; Interoperability">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>HyperService - The refreshing spring breeze bath</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Shaoyu Li&#39;s personal blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="HyperService"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-21 22:45" pubdate>
          June 21, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          136 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">HyperService</h1>
            
            <div class="markdown-body">
              
              <p>HyperService: Interoperability and Programmability Across Heterogeneous Blockchains</p>
<p>0. 摘要</p>
<p>区块链的互操作性，允许状态在不同的区块链之间传输，这对于促进主要的区块链发展很重要。存在的互操作性协议一般存在于区块链间原子代币的交换。然而，随着区块链由原来的分布式账本拓展为可编程状态机，区块链互操作性的范围也不再局限于仅仅的代币交换。这篇文章提出了 hyperservice，第一个平台可以实现互相操作性和可编程性跨越了异构的区块链。这个平台的能量来源于两个创新设计，（1）一个面向开发者的编程框架，允许开发者建立跨链应用在一个统一的编程模型。（2）一个安全的面向区块链的密码学协议，可证明地实现了这些应用在区块链上。</p>
<p>1. 引入</p>
<p>（为什么需要跨链互操作性，现在对于互操作性的要求）在今天区块链生态系统里，我们能看到很多不同的区块链，大概能分为公链，私链以及联盟链。在我们的世界里充斥着这么多的区块链，互相操作性 (interoperability) 就是动力。区块链的互相操作性允许在不同的区块链之间的安全状态传输，这对于连接去中心化 Web 3.0 是非常重要的。（Blockchain interoperability enables secure state transitions across different blockchains, which is invaluable for connecting the decentralized Web 3.0）现有的互操作性主要集中在两个区块链的代币交换，目标是减缓中心化交换的需求。然而，由于智能合约的出现，代币交换不是完全的区块链互操作性的全部。相反，区块链的互操作性应当是可编程性（programmability），允许用户来写分布式应用可以跨链执行。</p>
<p>（挑战）对于同步传递程序性和可互相操作性，有两类挑战。1、跨链去中心化应用的编程模型是不清楚的。（The programming model of cross-chain decentralized applications</p>
<p>(or dApps) is unclear.）从程序员的角度来说，跨链应用保护相同的基于状态机的编程抽象成只有一个链的合约。这个就存在一个挑战，即将异构的区块链中的智能合约和账户抽象出来，交互和操作才可以实现统一性。2、存在的代币交换驱动的互操作性协议，比如原子跨链交换并不够广泛地使用于跨链应用。原因是可执行的应用实际上需要包括比代币原子交换更多的复杂操作。举例，我们的应用可能会调用一个智能合约使用另一个区块链的智能合约参数。跨链应用的执行经常包含 **** 不同区块链之间的交易，**** 并且应用的正确性要求这些交易被执行在一定的前置条件或者截止日期的限制（preconditions and deadline constraints）另一个挑战是安全协调这些交易来确保应用在一个完全去中心化的零信任的环境里正确执行。</p>
<p>(What is HyperService?) HyperService is the first platform for building and executing dApps across heterogeneous blockchains. HS 有两个创新设计（注：前端 + 后端），第一个是面向开发者的编程框架，用于编写跨链 dapp，以及一个面向区块链的的密码学协议来在区块链上安全实现这些 dapps。</p>
<p>（前端）在这个编程框架，我们提出了 Unified State Model（USM）是一个区块链中立并且可拓展的模型来描述跨链 dapps。HSL is a high-level programming language to 写跨链 dApps 基于在 USM 编程模型。用 HSL 编写的 dApps 可以被编译进入 HyperService 可执行文件（executables），可执行文件可以进一步被底层协议执行（后端）。</p>
<p>（后端）Universal inter-blockchain protocol（UIP） 是密码学协议，可以处理跨链操作的复杂性。UIP 的属性：（1）generic，操作在任何区块链上以及一个公开的交易账本。（2）secure，dApps 的执行要么就通过可验证的正确性来完成，要么就由于安全隐患被舍弃，相关的 parties 需要负责任。（3）financially atomic， 所有参与的一方必须大多数为零经济损失，不管不顾 dapps 的执行状态。UIP is trust-free.</p>
<p>贡献</p>
<p>\1. 提出了第一个编程框架来开发跨链 dapps。这个框架在底层的异构区块链上面提供了一个虚拟层，可以使用一个统一的模型和一个高层次的语言来描述这些 dapps。</p>
<p>\2. 提出了 UIP, 第一个 generic blockchain 互操作性协议，他的设计范围超越了跨链的代币转换。UIP 可以实现安全完成复杂的跨链交换操作，包括智能合约被部署在异构区块链上。</p>
<p>\3. 代码实施，评估系统。</p>
<p>2.HyperService overview</p>
<p>架构</p>
<p>HyperService 由四部分组成：1.dApp Clients 是 dApps 的 gateway 与平台进行交互，一般希望比较轻便的客户端。2. Verifiable Execution Systems（VESes）工作就像是一个区块链驱动器（blockchain driver），编译高水平的 dApp programs 进入区块链可以执行的交易里面，然后就可以是运行时的可执行文件。UIP 自己包括两个部分：3 网络状态区块链（Network Status Blockchain， NSB）是一个区块链的区块链，在 HyperService 里提供一个客观的和统一的应用执行状态的视角。4. Insurance Smart Contracts（ISC），基于 NSB, ISC 可以判断出应用执行的正确与否，如果出现异常，ISC 最终会逆转所有的交易来保证经济的原子性以及让非法单位负责。</p>
<p>2.2 Universal State Model</p>
<p>一个能够执行智能合约的区块链往往被称为状态机。我们想为开发者提供相似的抽象当写跨链 dApps 时。USM 是一个区块链中立以及可拓展的模型，为了描述状态传输跨越不同的区块链，这个潜在地定义了跨链的应用。USM 实现了一个虚拟层来统一底下的异构区块链：1. 区块链被抽象为 objects with public state variables and functions，无论他们的实施（共识协议，智能合约环境，编程语言）。2. 开发者程序 dApps 被认为基于这些 objects 的操作，在这些操作中存在相关的顺序，好像是在一个机器中执行一样。</p>
<p>USM 被定义为三个部分，1.entities 的集合。实体实际上是用来描述 objects。对于 USM 来说，实体都是本地的。无论出自于什么区块链。实体有不同的种类，不同的种类有着不同的属性。当前的 USM 有两种实体，accounts 和 contracts。（扩展见 6.1）accounts 有独立的地址，余额以及某些单元（units）。一个合约实体有地址，以及一些公开属性（状态变量，可调用接口，部署在区块链的源码）2.operation performed over those entities，define a step of computation performed over several entities. 两种类型：payment，描述了余额在两个账户实体之间以某种汇率的更新。invocation，方法的执行特别是合约实体的接口使用兼容的参数，参数值通过其他合约实体状态变量获得。操作最终会被编译进入一个或者多个交易在不同的区块链中，共识过程可能是非同步的。为了解决事件中可能的依赖关系，定义了 3. constraints 来约束操作。现在的依赖有两种，preconditions 和 deadlines，preconditions 满足了，操作才可以继续，一个操作必须在一定时间间隔内完成。(i) preconditions enable developers to organize their operations into a directed acyclic</p>
<p>graph, where the state of upstream nodes is persistent and can be used by downstream nodes; (ii) deadlines are crucial to ensure the forward progress of dApp executions.</p>
<p>2.3 HSL(hyper service programming language)</p>
<p>2.3.1 引入的例子</p>
<p>建立一个 dApps（比如 voting）可以让参与者使用自己想使用的货币，而不仅仅是以太币。</p>
<p>2.3.2 HSL 程序编译</p>
<p>编程框架的核心是 HSL 的编译器（compiler）。这个编译器有两个任务，第一个是实现对于 HSL 程序安全和正确性的检查，第二个是编译 HSL 程序进入区块链可以执行的交易</p>
<p>我们的平台允许 dApps 来自然而然地定义异构区块链中智能合约的交互和操作。由于这些智能合约可以被写入不同的语言，HSL 提供了一个多语言前端来分析智能合约的源码。它提取了状态变量和函数的 type 信息，并且把他们转化为由 HSL 定义的统一 type。这允许有效的正确性核对在 HSL 程序里。</p>
<p>一旦一个 HSL 程序通过了语法和正确性检查，编译器会产生一个可执行文件（executable） for the program。可执行文件以 Transaction Dependency Graph 的形式，包括 1. 用于计算一系列区块链可执行交易的所有信息。2 每个交易进行正确执行所需要的元数据 3. 交易进行的预先条件以及截止时间表示的是依赖限制（&amp;3.4）。</p>
<p>Verifiable Execution Systems（VES） 是实际上拥有 HSL 编译器的实体。VES 就像是一个区块链的驱动器，连接高级的编程框架 with 底层的区块链。每一个 VES 实际上是一个分布式系统来提供无需信任的服务来编译并且执行 HSL 程序 given by dApps clients。VES 的行为实际上是可验证的。每个 VES 定义了他自己的服务模型，包括 reachability（VES 支持的区块链集合），用于正确执行的服务费，保险计划（预期的补偿如果这个执行是不正确的）。dApps 可以选择满足要求的 VESes。</p>
<p>\3. 编程框架</p>
<p>HS 的编程框架环绕着 HSL 的编译器. HSL 编译器有两个前端：一个是为了从一个 HSL 程序中提取 entities，operations，以及 dependencies。另一个是从区块链中的智能合约里提取公开的状态变量以及方法。一个统一类型的系统被设计于保证用不同语言编写的智能合约可以被抽象成互操作性实体。编译器进行语义验证（semantic validation）在所有的实体，操作以及依赖上来确保 HSL 程序的安全性和正确性。最后，编译器产生了一个可执行文件 for HSL 程序。</p>
<p>3.1 Unified Type System</p>
<p>USM wants to offer 一个统一地虚拟层让开发者可以定义调用操作在他们的 HSL programs，而不需要处理合约实体的异构性。UTS 状态变量和函数可以被抽象为使用相同的种类，当写 HSL 程序的时候。这就保证了调用操作参数的兼容性。9 种基础类型见表 2. 在编译的时候，数据种类需要被 mapping 到统一地种类。不同语言对于数据类型的定义会有不同，因此我们平台的多语言前端识别这些区别，并且进行 type 转换来映射所有的 type。</p>
<p>3.2 HSL 语言的设计</p>
<p>Import 被加在导入合约实体的源码。（我猜智能合约不会存储源码，只能存储编码值）。为了安全考虑，编译器需要验证导入的源码确实是实际上部署在区块链的源码，比如比较 compiled byte code。</p>
<p>实体定义</p>
<p>&lt;entity_def&gt; 表示 account 和 contract 的定义，通过构造函数，需要 on-chain (<address>) 作为参数</p>
<p>&lt;op_def&gt; 指定 payment 或者 invocation</p>
<p>&lt;dep_def&gt; 指定依赖的规则</p>
<p>3.3 语义的合法性</p>
<p>编译器提供两种语义的合法性来保证 HSL 程序的安全性和正确性。首先，编译器维护了参数的一致性和可验证性在使用 invocation 时。一致性检测指的是编译器会检测参数的类型以及方法参数的类型来映射到相同的 type。对于可验证性检测，编译器保证只有文字和区块链公开的状态变量可以被用于 invocation 的参数。举例而言，方法的返回值调用另一个合约实体，如果这些结果没有存储在区块链里，则是不合法的。这个为了 UIP 模型来构建公开的可验证的证明来验证正确的值被用于调用智能合约在事实上的链上执行时。第二，编译器表现依赖合法性来确保依赖唯一指定一个非环图，连接所有的操作。</p>
<p>3.4 HSL program executables</p>
<p>一旦程序通过了所有的合法性检查，编译器产生可执行文件 for the program 以交易依赖图的形式。每个交易依赖图的端点表示被封装的交易，包括完全的信息来计算链上交易可执行文件在一个特殊的区块链。图的边缘表示预条件的要求，先执行什么，后执行什么。</p>
<p>后端</p>
<p>2.4 Universal Inter-Blockchain Protocol（UIP）</p>
<p>为了正确执行 dApp，所有可执行文件里的交易必须放到区块链上进行执行，与此同时，他们的预条件和截止时间也是接受的。即使执行流程很简单，但是非常挑战去强迫正确执行在一个没有信任的地方，这里 1 没有信任的认证被允许来协调不同区块链的执行，2 没有在 VESes 和 dApps 之间建立信任。</p>
<p>为了解决这个挑战，HS 设计一个 UIP，一个在 VES 和 dApps 客户端之间的密码学协议来在区块链上安全执行 HSL 可执行文件。UIP 为执行 dApps 提供了强安全保障，这就导致 dApps 可以正确地执行仅当正确性被股权持有者公共验证过，否则，UIP 会向不诚实的单位进行追责，最后回退所有的交易来实现经济原子性。</p>
<p>UIP 有两个创新性的设计，网络状态区块链（Network Status Blockchain，NSB），and Insurance Smart Contract（ISC）。NSB 是一个由 HS 设计的区块链来提供 objective and unified views on the status of dApp executions. 一方面来说，NSB 统一了底层区块链 s 的最终交易进入 merkle tree，提供了统一的表达。另一方面，NSB 支持 proof of actions（PoAs），允许 dApps clients 和 VESes 构建证明来验证他们的行为发生在跨链执行中。ISC 是一个代码仲裁者，他使用交易状态证明，由 NSB 构建作为输入来决定 dApps 执行的正确与否，与此同时使用动作证明来决定负责任单位万一有异常.</p>
<p>4 UIP  design detail</p>
<p>​</p>
<p>UIP is the cryptography protocol that executes HSL program executables.</p>
<p>PROTuip = PROTves+PROTcli+PROTnsb+PROTisc+PROTbc</p>
<p>PROTuip 有两个阶段，一个是执行阶段，将执行文件中的交易放在区块链里面。第二个是保险声明阶段，执行正确与否会被仲裁。（Overall, ProtUIP has two phases: the execution phase where the transactions specified in the HSL executables are posted on blockchains and the insurance claim phase where the execution correctness or violation is arbitrated.）</p>
<p>4.1 协议基础</p>
<p>4.1.1 运行时间交易状态</p>
<p>在执行阶段，tx 必须在以下状态，{unknown, init, inited, open, opened, closed}，后面的状态比前面的 advanced。每个交易状态都按照顺序渐渐提升。对于每一个状态，uip 产生相关的证明（attestation）来证明这个状态。当执行阶段停止时，最终执行状态由所有交易状态决定，基于 Isc 仲裁正确与否。</p>
<p>4.1.2 链下状态信道</p>
<p>VES 和 CLIENTS 之间存在协议交换通过链下状态信道为了低延迟。挑战：很难去确认责任对于没有关闭的交易没有被两方保存执行步骤。为了解决这个问题，UIP 提出了 PoAs，让 VES 和 Client 在 NSB 来为他们的执行步骤做抵押。NSB 是一个公开可观察 fallback（可依靠的，退却）的链下信道交流中介。这种双介质设计的好处是，ProtVES 和 ProtCLI 之间的协议交换在典型场景下仍然可以通过链下通道敏捷进行，而在异常情况下，它们的协议交换的完整粒度保存在 NSB 上，消除了责任执行的模糊性。</p>
<p>在 4.1.1 种提出的 UIP 对于交易的运行时间状态进行安全证明，有两种形式，1.a certificate, denoted by Cert, signed by VES or/and CLIENT 在他们进行链下交换时进行。<a target="_blank" rel="noopener" href="http://2.an">2.an</a> on-chain Merkle Proof, 表示为 Merk，使用 NSB 和底层区块链来架构。An Cert 和他相关的 Merk 被认为平等 by ISC, 在代码仲裁时。</p>
<p>4.1.3 NSB 的框架</p>
<p>NSB 是一个区块链来提供一个对象视角在 dApps 状态的执行上。（The NSB is a blockchain designed to provide an objective view on the execution status of dApps.）类似于典型的区块链区块，NSB 区块包括了一些相似的领域，比如哈希值来连接区块，以及 Merkle tree 来存储交易和状态。为了支持额外的功能，NSB 区块包括了两个额外的 MERKLE TREE ROOTS: STATE ROOT AND ACTION ROOT.</p>
<p>（StatusRoot is the root of a Merkle tree (referred as StatusMT) that stores transaction status of underlying blockchains. The NSB represents the transaction status of a blockchain based on the Tx-Roots and StateRoots retrieved from the blockchain’s public ledger.）Status root 是存储底层区块链交易状态的的默克尔树的根哈希值（问题：谁来收集数据？），NSB 表达了底层区块链的交易状态基于 Txroot 和 Statusroot（问题：组织问题？）（问题：NSB 更新时间），NSB 只存储相关的区块链状态，区块链的区块相关性：如果区块链的包种最少一个交易是与 dApps 执行相关。（Note that the NSB only stores relevant blockchain state, where a blockchain</p>
<p>block is considered to be relevant if the block packages at least one transaction that is part of any dApp executables.）</p>
<p>（ActionRoot is the root of a Merkle tree (referred to as ActionMT) whose leaf nodes store certificates computed by VESes and dApp clients.Each certificate represents a certain step taken by either the VES or the dApp client during the execution phase. To prove such an action, a party needs to construct a Merkle proof to demonstrate that the certificate mapped to the action can be linked to a committed block on the NSB.）ActionRoot 是 merkle 树的 root，这个树的叶节点存储了由 VES 和 clients 计算的认证。每一个 Certificate 表示一个 VES 或者 dApps 在执行阶段采用的特定的步骤。为了证明一个 action，一个 party 需要构建一个 merkle proof 来证明这个 certificate 匹配的 action 可以被连接到被 committed 的区块链的区块上。这写 PoA 对于 ISC 来确定责任是十分重要的，当执行失败时。因为每个 actionMT 的信息都是静态的，按照字典顺序给信息排序来达到快速搜索以及方便进行不存在证明。</p>
<p>请注意，StatusMT 的构建确保了每个底层区块链都可以有一个专用的子树来存储其交易状态。这使得 NSB 可以在单个区块链的粒度上进行分片，从而确保 NSB 在 HyperService 不断合并其他区块链时具有水平可扩展性。 ProtNSB，在第 4.5 节中讨论，是指定两个根的详细构造并保证其正确性的协议</p>
<p>4.2 Execution Protocol by VESes</p>
<p>4.2.1 Post Compilation and Session Setup</p>
<p>在可执行文件被产生后，VES 初始化了一个执行 session 在 PostCompilation daemon。目标是创造和部署一个 insurance contract 来保护文件的执行（The primary goal of the initialization is to create and deploy an insurance contract to protect the execution of file）。VES interacts with ISC 来创造一个保险合同，在 ves 和 cli 都签完字之后部署这个合约在 NSB 上。</p>
<p>Cert([∗]; Sig) represents a signed certificate proving that the signing party agrees on the value</p>
<p>enclosed in the certificate. We use SigVsid and SigDsid to represent the signature by ProtVES and ProtCLI, respectively.</p>
<p>除此之外，VES 和 CLI 需要存储足够的资金给 ISC 确保 ISC 可以在经济上回退交易。在交易完成后 ISC 会退剩下的钱。关于存钱的额度，有一个算法，在这里不做赘述。</p>
<p>T. from =ProtVES or T is originated from ProtVES, we mean that T is sent and signed by an account owned by ProtVES. Likewise, T.from =ProtCLI indicates that T is sent from an account entity defined in the HSL program.</p>
<p>SCert and SMerk represent two sets that store the signed certificates received via off-chain channels and on-chain Merkle proofs constructed using ProtNSB and ProtBC.</p>
<p>4.2.2 交易处理的协议交换</p>
<p>SlnitedTrans 和 OpenTrans 是两个处理器进程北界交易（northbound tx），由 VES 产生。SlnitedTrans 处理 T 被引用，当所有的预条件满足，预条件被 VES 用 watching service 检测。SIT 计算 cert_id_T 来证明 T 在 inited state，然后传递给 CLI. 同时，SIT 质押 CertidT 于 NSB 上，后来会检索一个 MerkiT from NSB 来证明 CertidT 已经送达。</p>
<p>The OpenTrans 处理器和 SIT 是一对。它监听一个时间戳 CertoT, 应该由 PROTcli 产生在 CLI 处理完 CertidT 之后。OpenTrans 表现出特定的正确性检查在 tsopen，被 CertoT 包围。时间的话，使用 NSB 的块高度来标准化钟。VES 通过 check tsopen 是在一个 NSB 高度的边界范围内，来确保 tsopen 是 fresh 的。在所有对于 CertidT 的正确性检查之后，T 的状态被提升从 open 到 opened。OpenTrans 然后计算 certificates 来证明更新的状态，并且把 T - 放在目标区块链上为了链上执行。Throughout the paper, T- denotes the on-chain executable transaction computed and signed using the information contained in T. a post-open (i.e., opened)</p>
<p>certificate CertodT computed by ProtVES is signed by both parties. Only the tsopen specified in CertodT is used by ProtISC when evaluating the deadline constraint of T.</p>
<p>南界交易（Southbound transactions）由 cli 产生，传给 VES，和北界交易类似。We clarify a subtlety in the RInitedTrans handler when verifying the association between Te and T (line 61). If T- depends on the resulting state from its upstream transactions (for instance, T4 depends on the resulting state of T1 in Figure 4), ProtVES needs to verify that the state used by T- is consistent with the state enclosed in the finalization proofs of those upstream transactions.</p>
<p>4.2.3 主动观看服务</p>
<p>VES 是执行的驱动器。ProtVES internally creates two watching services to proactively read the status of the underlying blockchains and NSB.</p>
<p>在观察一个外界的区块链时，VES 主要阅读公众的区块链账本来监视与链上执行有关的交易状态。如果 ves 发现有一个最近的链上交易 T - 最终化，他会要求关闭 T 的交易进程，通过发送给 CLI 一个时间戳认证 Cclosed。两者同时调用 CloseTrans 和 ClosedTrans 来结束。</p>
<p>ProtVES mainly reads the public ledger of ProtBC to monitor the status of transactions that have been posted for on-chain execution. If ProtVES notices that an on-chain transaction T- is recently finalized, it requests the closing process for T by sending ProtCLI a timestamped certificate Cclosed. The pair of handlers, CloseTrans and ClosedTrans, are used by both ProtVES and ProtCLI in this exchange. Both handlers can be used for handling northbound and southbound transactions, depending on which party sends the closing request. In general, a Transaction’ s originator has a stronger motivation to initiate the closing process because the originator would be held accountable if the transaction were not timely closed by its deadline.</p>
<p>另外 VES 需要在 BC 里检索 T - 的最终话 merkle proof Merkc1T. 有两个目的，这是完成链上证明的第一个步骤，其次，如果被下游函数利用，Merkc1T 确保下游函数利用的是 genuine 状态。</p>
<p>In addition, ProtVES needs to retrieve a Merkle Prooffrom ProtBC to prove the finalization ofeT. This proof, denoted by Merkc1T, serves two purposes: (i) it is the first part of a complete on-chain proof to prove that the state eT can be promoted to closed, as shown in Figure 7; (ii) if the resulting state of eT is used by its downstream transactions, Merkc1T is necessary to ensure that those downstream transactions indeed use genuine state.</p>
<p>当观察 NSB 时，ves 表达了以下的工作。首先，NSB 被认为是一个公正的交流中介 for 链下信道。因此，ves 搜索 ActionMT 来查找任何于 session 相关的 cert 是不是有没有被收到的通过链下信道。第二，对于每一个 T，closed 的证明还丢失在 VES 送 Cclosed 之后，指 CLI 没有反应或者很慢。Ves 尝试去检索 Merkc2T 来证明 Merkc1T 确实连接了 NSB 的 StatusRoot。一旦完成证明，T 被认定为 closed。最后，VES 可能找到一个新的交易集合，有资格来被执行，如果预条件满足在最近的交易里。VES 处理他们要么要求初始化 from CLI, 或者 call SIT 取决于交易的产生。</p>
<p>4.2.4 ISC invocation</p>
<p>VES 周期性调用 ISC 来执行合约。所有的 merkle proofs 和 certificates 是可被接受的。然而，对于任意一个 T， VES 应该调用 ISC 仅仅使用证明 with the 最先进的状态，因此，低排名的往往会被忽略。</p>
<p>4.3 Execution Protocol by dApp Clients</p>
<p>ProtCLI specifies the protocol implemented by dApp clients. ProtCLI defines the following set of handlers to match ProtVES. In particular, the InitedTrans and OpenedTrans match the SInitedTrans and OpenTrans of ProtVES, respectively, to process Certid and Certod sent by ProtVES when handling transactions originated from ProtVES. The InitTrans and OpenTrans process Certi and Certo sent by ProtVES when executing transactions originated from ProtCLI.The CloseTrans and ClosedTrans of ProtCLI match their counter parts in ProtVES to negotiate closing attestations.</p>
<p>For usability, HyperService imposes smaller requirements on the watching daemons implemented by ProtCLI. Specially, ProtCLI still proactively watches ProtNSB to have a fallback communication medium with ProtVES. However, ProtCLI is not required to proactively watch the status of underlying blockchains or dynamically compute eligible transactions whenever the execution status changes. We intentionally offload such complexity on ProtVES to enable lightweight dApp clients. ProtCLI, though, should (and is motivated to) check the status of self-originated transactions in order to request transaction closing.</p>
<p>4.4 Protocol Realization of the ISC</p>
<p>The CreateContract handler is the entry point ofrequesting insurance contract creation using ProtISC. It generates the arbitration code, denoted as contract, based on the given dApp executable GT. The contract internally uses Tstate to track the state of each transaction in GT,</p>
<p>which is updated when processing security attestations in the InsuranceClaim handler. For clear presentation, Figure 8 extracts the state proof and fund reversion tuple from T as dedicated variables stproof and Arevs. When the ProtISC times out, it executes the contract terms based on its internal state, after which its funds are depleted and the contract never runs again. Below we explain several technical subtleties.</p>
<p>4.4.1 Insurance Claim</p>
<p>The InsuranceClaim handler processes security attestations from ProtVES and ProtCLI. Only dual-signed certificates (i.e., Certod and Certc ) or complete Merkle proofs are acceptable. Processing dual signed certificates is straightforward as they are explicitly agreed by both parties. However, processing Merkle proof requires additional correctness checks. First, when validating a Merkle proof MerkiT, MerkidT or MerkoT, ProtISC retrieves the single-party signed certificate CertiT, CertidT or CertoT enclosed in the proof and performs the following correctness check against the certificate. (i) The certificate must be signed by the correct party, i.e., CertiT is signed by ProtVES, CertidT is signed by T’s originator and CertoT is signed by the destination ofT. (ii) The enclosed on-chain transaction eT in CertidT and CertoT is correctly associated with T. The checking logic is the same as the on used by ProtVES, which has been explainedin § 4.2.2. (iii) The enclosed tsopen in CertoT is genuine, where the genuineness is defined as a bounded difference between tsopen and the height of the NSB block that attaches MerkoT.</p>
<p>4.4.2 Contract Term Settlement</p>
<p>ProtISC registers a callback SettleContract to execute contract terms automatically upon timeout. ProtISC internally defines an additional transaction state, called correct. The state of a closed transaction is promoted to correct if its deadline constraint is satisfied. Then, ProtISC computes the possible dirty transactions in GT, which are the transactions that are eligible to be opened, but with non-correct state. Thus, the execution succeeds only if GT has no dirty transactions. Otherwise, ProtISC employs a decision tree, shown in Figure 9, to decide the responsible party for each dirty transaction. The decision tree is derived from the execution steps taken by ProtVES and ProtCLI. In particular, if a transaction T’s state is closed, opened or open, then it is T’s originator to blame for either failing to fulfill the deadline constraint or failing to dispatch eT for on-chain execution. If a transaction T’s state is inited, then it is T’s destination party’s responsibility for not proceeding with T even though Certid T has been provably sent. If a transaction T’s state is init (only transactions originated from dApp D can have init status), then D (the originator) is the party to blame for not reacting on the CertiT sent by V. Finally, if transaction T’s state is unknown, then V is held accountable for not proactively driving the initialization ofT, no matter which party originates T.</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Research/" class="category-chain-item">Research</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Blockchain-Interoperability/">#Blockchain; Interoperability</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>HyperService</div>
      <div>http://example.com/2022/06/21/HyperService/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Shaoyu Li</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>June 21, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/11/Summary-of-Bitcoin-white-paper/" title="Summary-of-Bitcoin-white-paper">
                        <span class="hidden-mobile">Summary-of-Bitcoin-white-paper</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
